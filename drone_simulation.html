<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Controllable Quadcopter Landing on Moving Truck</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #87ceeb; font-family: sans-serif;
    }
    canvas { display: block; }
    button {
      position: absolute; top: 10px;
      padding: 6px 12px; font-size: 14px;
      cursor: pointer; z-index: 20;
    }
    #startBtn { left: 10px; }
    #stopBtn  { left: 90px; }
    #resetBtn { left: 170px; }

    input[type=range] {
      position: absolute; width: 160px; z-index: 20;
    }
    #windSlider { top: 50px;  left: 60px; }
    #tiltSlider{ top: 90px;  left: 140px; }

    .label {
      position: absolute; z-index: 20;
      color: #fff; background: rgba(0,0,0,0.5);
      padding: 2px 6px; font-size: 14px; border-radius: 4px;
    }
    #windLabel  { top: 50px;  left: 10px; }
    #windValue  { top: 50px;  left: 230px; }
    #tiltLabel  { top: 90px;  left: 10px; }
    #tiltValue  { top: 90px;  left: 310px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "p5":        "https://cdn.skypack.dev/p5@1.4.0",
      "matter-js": "https://cdn.skypack.dev/matter-js@0.18.0"
    }
  }
  </script>
</head>
<body>
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
  <button id="resetBtn">Restart</button>

  <span id="windLabel" class="label">Wind:</span>
  <input type="range" id="windSlider" min="0" max="20" step="1" value="0">
  <span id="windValue" class="label">0</span>

  <span id="tiltLabel" class="label">Platform Tilt:</span>
  <input type="range" id="tiltSlider" min="-30" max="30" step="1" value="0">
  <span id="tiltValue" class="label">0Â°</span>

  <script type="module">
    import p5 from 'p5';
    import Matter from 'matter-js';
    const { Engine, World, Bodies, Body } = Matter;

    // ----- Constants -----
    const DRONE_WIDTH          = 40;
    const DRONE_HEIGHT         = 10;
    const PLATFORM_WIDTH       = 100;
    const PLATFORM_HEIGHT      = 10;
    const ROAD_HEIGHT          = 40;
    const WHEEL_DIAMETER       = 20;
    const TRUCK_X_FRACTION     = 0.3;
    const DASH_LENGTH          = 40;
    const DASH_GAP             = 30;
    const ROAD_SCROLL_SPEED    = 200;

    const USER_THRUST          = 0.0005;
    const DRAG_COEFFICIENT     = 0.00002;
    const LANDING_GAP          = 5;

    // ----- State -----
    let physicsEngine, physicsWorld;
    let droneBody, platformBody;
    let isLanded             = false;
    let isSimulationRunning  = true;
    let currentWindForce     = 0;
    let platformTiltAngle    = 0;
    let currentDashOffset    = 0;
    let currentSpinAngle     = 0;
    const SPIN_SPEED         = 0.3;

    let backgroundBuffer, skyColorTop, skyColorBottom;

    function initializeSimulation(sketch) {
      physicsEngine = Engine.create();
      physicsWorld  = physicsEngine.world;
      physicsWorld.gravity.y     = 0;
      physicsWorld.gravity.x     = 0;
      physicsWorld.gravity.scale = 0;
      World.clear(physicsWorld, false);

      const truckX    = sketch.width * TRUCK_X_FRACTION;
      const platformY = sketch.height - ROAD_HEIGHT/2 - PLATFORM_HEIGHT/2;

      // Drone
      droneBody = Bodies.rectangle(
        truckX, 100,
        DRONE_WIDTH, DRONE_HEIGHT,
        { frictionAir: 0.05, density: 0.001, restitution: 0, friction: 0.1 }
      );

      // Static Platform
      platformBody = Bodies.rectangle(
        truckX, platformY,
        PLATFORM_WIDTH, PLATFORM_HEIGHT,
        { isStatic: true, friction: 0.8, restitution: 0.1 }
      );

      World.add(physicsWorld, [droneBody, platformBody]);

      isLanded            = false;
      isSimulationRunning = true;
      currentDashOffset   = 0;
      currentSpinAngle    = 0;
    }

    function drawBackground(sketchGraphics, sketch) {
      for (let y = 0; y < sketch.height; y++) {
        const t = y / sketch.height;
        sketchGraphics.stroke(sketch.lerpColor(skyColorTop, skyColorBottom, t));
        sketchGraphics.line(0, y, sketch.width, y);
      }
      sketchGraphics.noStroke();
      sketchGraphics.fill(255,255,255,200);
      for (let i = 0; i < 8; i++) {
        const cx = Math.random() * sketch.width;
        const cy = Math.random() * sketch.height * 0.4;
        const cw = 60 + Math.random()*80;
        const ch = 20 + Math.random()*20;
        sketchGraphics.ellipse(cx, cy, cw, ch);
        sketchGraphics.ellipse(cx + cw*0.3, cy - ch*0.2, cw*0.6, ch*0.6);
        sketchGraphics.ellipse(cx - cw*0.3, cy - ch*0.1, cw*0.5, ch*0.5);
      }
    }

    function renderRoad(sketch) {
      const roadY = sketch.height - ROAD_HEIGHT/2;
      sketch.fill(50);
      sketch.noStroke();
      sketch.rect(sketch.width/2, roadY, sketch.width, ROAD_HEIGHT);

      sketch.fill(255);
      let dashStart = -currentDashOffset;
      while (dashStart < sketch.width) {
        sketch.rect(dashStart + DASH_LENGTH/2, roadY, DASH_LENGTH, 4);
        dashStart += DASH_LENGTH + DASH_GAP;
      }
    }

    function renderTruckPlatform(sketch) {
      const x = platformBody.position.x;
      const y = platformBody.position.y;

      // Apply tilt to platform body for later math
      Body.setAngle(platformBody, platformTiltAngle);

      // Chassis
      sketch.push();
      sketch.translate(x, y);
      sketch.fill(80);
      sketch.noStroke();
      sketch.rect(0, 0, PLATFORM_WIDTH, PLATFORM_HEIGHT);
      sketch.pop();

      // Tyres
      const offsetX = PLATFORM_WIDTH*0.3;
      const wheelY  = y + PLATFORM_HEIGHT/2 + WHEEL_DIAMETER/2;
      [-offsetX, offsetX].forEach(sign => {
        sketch.fill(0);
        sketch.noStroke();
        sketch.ellipse(x + sign, wheelY, WHEEL_DIAMETER, WHEEL_DIAMETER);
        sketch.fill(150);
        sketch.ellipse(x + sign, wheelY, WHEEL_DIAMETER*0.6, WHEEL_DIAMETER*0.6);
      });

      // Gridded bed
      const bedWidth = PLATFORM_WIDTH*0.6;
      sketch.push();
      sketch.translate(x, y - PLATFORM_HEIGHT);
      sketch.rotate(platformTiltAngle);
      sketch.fill(100);
      sketch.noStroke();
      sketch.rect(0,0, bedWidth, PLATFORM_HEIGHT);
      sketch.stroke(150);
      sketch.strokeWeight(2);
      for (let i=1; i<6; i++){
        let lineX = -bedWidth/2 + (bedWidth/6)*i;
        sketch.line(lineX, -PLATFORM_HEIGHT/2, lineX, PLATFORM_HEIGHT/2);
      }
      sketch.pop();

      // Cargo box (right)
      sketch.fill(255,204,0);
      sketch.rect(x + PLATFORM_WIDTH/2 - 15, y - PLATFORM_HEIGHT - 10, 30,20);

      // Loading deck (left)
      sketch.fill(120);
      sketch.rect(x - PLATFORM_WIDTH/2 + 15, y + PLATFORM_HEIGHT/2 + 3, 30,6);
    }

    function renderDrone(sketch) {
      const x      = droneBody.position.x;
      const y      = droneBody.position.y;
      const angle  = droneBody.angle;
      const offset = DRONE_WIDTH/2;

      sketch.push();
      sketch.translate(x,y);
      sketch.rotate(angle);

      // Body
      sketch.fill(255,204,0);
      sketch.noStroke();
      sketch.rect(0,0, DRONE_WIDTH, DRONE_HEIGHT);

      // Rotors
      [-offset, offset].forEach(hubX => {
        sketch.fill(0);
        sketch.ellipse(hubX,0,8,8);
        sketch.push();
        sketch.translate(hubX,0);
        sketch.stroke(0); sketch.strokeWeight(2);
        sketch.rotate(currentSpinAngle);
        sketch.line(-10,0,10,0);
        sketch.rotate(Math.PI/2);
        sketch.line(-10,0,10,0);
        sketch.pop();
        sketch.noStroke();
      });

      sketch.pop();
    }

    // ----- p5 Sketch -----
    const sketch = s => {
      s.setup = () => {
        s.createCanvas(s.windowWidth, s.windowHeight);
        s.rectMode(s.CENTER);
        s.angleMode(s.RADIANS);

        skyColorTop       = s.color(135,206,235);
        skyColorBottom    = s.color(250,222,156);
        backgroundBuffer  = s.createGraphics(s.width, s.height);
        drawBackground(backgroundBuffer, s);

        initializeSimulation(s);
      };

      s.windowResized = () => {
        s.resizeCanvas(s.windowWidth, s.windowHeight);
        backgroundBuffer = s.createGraphics(s.width, s.height);
        drawBackground(backgroundBuffer, s);
        const newY = s.height - ROAD_HEIGHT/2 - PLATFORM_HEIGHT/2;
        Body.setPosition(platformBody, { x:platformBody.position.x, y:newY });
      };

      s.draw = () => {
        const dt = s.deltaTime/1000;
        if (isSimulationRunning) {
          Engine.update(physicsEngine, s.deltaTime);
          currentDashOffset = (currentDashOffset + ROAD_SCROLL_SPEED*dt) % (DASH_LENGTH+DASH_GAP);
          if (!isLanded) currentSpinAngle += SPIN_SPEED;

          // Wind force
          Body.applyForce(droneBody, droneBody.position, { x:currentWindForce, y:0 });
          // Drag
          const vel = droneBody.velocity;
          Body.applyForce(droneBody, droneBody.position, {
            x: -DRAG_COEFFICIENT*vel.x*Math.abs(vel.x),
            y: -DRAG_COEFFICIENT*vel.y*Math.abs(vel.y)
          });

          // User thrust
          if (!isLanded) {
            if (s.keyIsDown(s.LEFT_ARROW ))  Body.applyForce(droneBody, droneBody.position, { x:-USER_THRUST, y:0 });
            if (s.keyIsDown(s.RIGHT_ARROW))  Body.applyForce(droneBody, droneBody.position, { x: USER_THRUST, y:0 });
            if (s.keyIsDown(s.UP_ARROW   ))  Body.applyForce(droneBody, droneBody.position, { x:0, y:-USER_THRUST });
            if (s.keyIsDown(s.DOWN_ARROW ))  Body.applyForce(droneBody, droneBody.position, { x:0, y: USER_THRUST });
          }

          // Landing & attach to tilted platform
          const sumOffset = PLATFORM_HEIGHT/2 + DRONE_HEIGHT/2 + LANDING_GAP;
          const landingY  = platformBody.position.y - sumOffset;
          const dxError   = Math.abs(droneBody.position.x - platformBody.position.x);

          if (!isLanded
              && droneBody.position.y >= landingY
              && dxError <= (PLATFORM_WIDTH*0.6)/2
              && Math.hypot(vel.x, vel.y) < 0.5) {
            isLanded = true;
            Body.setStatic(droneBody, true);
          }
          // If landed, update drone position & angle with platform tilt
          if (isLanded) {
            const cosA = Math.cos(platformTiltAngle);
            const sinA = Math.sin(platformTiltAngle);
            const worldX = platformBody.position.x + sinA * sumOffset;
            const worldY = platformBody.position.y - cosA * sumOffset;
            Body.setPosition(droneBody, { x: worldX, y: worldY });
            Body.setAngle(droneBody, platformTiltAngle);
          }
        }

        // Draw scene
        s.image(backgroundBuffer,0,0);
        renderRoad(s);
        renderTruckPlatform(s);
        renderDrone(s);

        // Instructions (below controls)
        s.fill(0);
        s.textSize(16);
        s.textAlign(s.LEFT, s.TOP);
        s.text('Arrow keys: fly drone', 10, 140);
        s.text('Sliders: wind & tilt', 10, 160);

        // Success message
        if (isLanded) {
          s.fill(0,200,0);
          s.textSize(24);
          s.textAlign(s.CENTER, s.CENTER);
          s.text('Success! Drone landed.', s.width/2, s.height/2);
        }
      };
    };

    window.p5Instance = new p5(sketch);

    // ----- UI Hooks -----
    document.getElementById('startBtn').addEventListener('click', () => {
      isSimulationRunning = true;
    });
    document.getElementById('stopBtn').addEventListener('click', () => {
      isSimulationRunning = false;
    });
    document.getElementById('resetBtn').addEventListener('click', () => {
      initializeSimulation(window.p5Instance);
      document.getElementById('windSlider').value = 0;
      document.getElementById('tiltSlider').value = 0;
      currentWindForce  = 0;
      platformTiltAngle = 0;
      document.getElementById('windValue').textContent = '0';
      document.getElementById('tiltValue').textContent = '0Â°';
    });
    document.getElementById('windSlider').addEventListener('input', e => {
      currentWindForce = Number(e.target.value) * 0.00002;
      document.getElementById('windValue').textContent = e.target.value;
    });
    document.getElementById('tiltSlider').addEventListener('input', e => {
      platformTiltAngle = Number(e.target.value) * Math.PI/180;
      document.getElementById('tiltValue').textContent = `${e.target.value}Â°`;
    });
  </script>
</body>
</html>
