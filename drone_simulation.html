<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Quadcopter Landing Simulation (Realistic)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2176FF;
      --success: #19cb61;
      --danger: #ff4156;
      --background: #f5f8fa;
      --surface: #fff;
      --text: #24292f;
      --shadow: 0 2px 10px rgba(33, 34, 90, 0.10);
      --border: #e3e8ee;
    }
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      height: 100%; width: 100vw; background: var(--background);
      font-family: 'Roboto', Arial, sans-serif; color: var(--text);
    }
    body {
      display: flex; flex-direction: row; height: 100vh;
    }
    #sidebar {
      width: 340px; min-width: 280px; max-width: 400px; height: 100vh;
      background: linear-gradient(135deg, #e8f0ff 70%, #ffffff 100%);
      box-shadow: 2px 0 12px #aec8ed38;
      z-index: 100; display: flex; flex-direction: column;
      padding: 0 24px; border-right: 1px solid var(--border);
      position: relative;
    }
    #sidebar h1 {
      font-size: 1.8rem; color: var(--primary); margin: 32px 0 8px 0;
      font-weight: 700; text-shadow: 1px 2px 4px #d4e2f8;
      letter-spacing: -1.5px;
    }
    #sidebar .section {
      margin-bottom: 22px;
    }
    #sidebar .label {
      font-size: 1rem; color: #6d8abe;
      margin-bottom: 3px; margin-top: 14px;
      display: block; font-weight: 500;
    }
    #sidebar input[type=range] {
      width: 190px; accent-color: var(--primary);
      margin: 0 10px 0 0;
    }
    #sidebar .slider-row {
      display: flex; align-items: center; margin-bottom: 7px;
    }
    #sidebar .value-label {
      font-weight: 700; font-size: 1.1em; margin-left: 7px;
      color: var(--primary);
      min-width: 36px; display: inline-block;
    }
    #sidebar button {
      font-size: 1.03em; padding: 8px 22px;
      background: var(--primary); color: #fff; border: none;
      border-radius: 6px; box-shadow: var(--shadow);
      margin-right: 10px; margin-bottom: 10px; cursor: pointer;
      transition: background .16s, transform .12s;
      font-weight: 700; letter-spacing: 0.5px;
    }
    #sidebar button:hover:not(:disabled) {
      background: #1457b2; transform: translateY(-2px) scale(1.04);
    }
    #sidebar button:disabled {
      background: #aacaf7; cursor: not-allowed;
    }
    #instructions {
      background: #eef4fd; border-radius: 8px; padding: 12px 15px;
      font-size: 1.02em; color: #52627a; margin-bottom: 6px;
      box-shadow: 0 2px 8px #e1e7f5a9;
      line-height: 1.52;
    }
    #telemetry {
      background: #f8fbff; border-radius: 10px;
      padding: 12px 16px; box-shadow: 0 2px 8px #e1e7f5b7;
      font-size: 1.04em; color: #222; margin-bottom: 8px;
    }
    #telemetry .t-label { color: #6e82a1; font-weight: 500; }
    #telemetry .t-value { float: right; font-weight: 700; color: var(--primary);}
    #statusMsg {
      font-weight: 700; font-size: 1.28em;
      margin-top: 18px;
      border-radius: 7px; padding: 7px 14px;
      box-shadow: 0 2px 8px #e1e7f5b7;
      display: inline-block;
      text-align: center;
    }
    #statusMsg.success { background: #d6ffe6; color: var(--success); }
    #statusMsg.crash { background: #ffe5e8; color: var(--danger);}
    #statusMsg.flying { background: #e7f1ff; color: var(--primary);}
    #canvas-container {
      flex: 1 1 0; height: 100vh; position: relative; overflow: hidden;
      z-index: 1;
    }
    canvas {
      display: block; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
      pointer-events: none; /* All interactions are on sidebar only */
    }
    @media (max-width: 600px) {
      #sidebar { width: 98vw; max-width: 100vw; min-width: unset; padding: 0 8vw;}
      #canvas-container { display: none; }
      body { flex-direction: column; }
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "p5":       "https://cdn.skypack.dev/p5@1.4.0",
        "matter-js": "https://cdn.skypack.dev/matter-js@0.18.0"
      }
    }
  </script>
</head>
<body>
  <div id="sidebar">
    <h1>Drone Landing Sim</h1>
    <div class="section" id="instructions">
      <div><b>Instructions:</b></div>
      <ul style="margin: 8px 0 0 12px; padding-left: 12px; font-size: 1em;">
        <li>Use <b>Arrow keys</b> to control the drone.</li>
        <li>Land on the <b>tilted platform</b> safely.</li>
        <li>Avoid crashing or flying off the screen!</li>
        <li>Adjust <b>wind</b> and <b>platform tilt</b> with sliders.</li>
      </ul>
    </div>
    <div class="section">
      <span class="label">Wind:</span>
      <div class="slider-row">
        <input type="range" id="windSlider" min="0" max="20" step="1" value="0">
        <span class="value-label" id="windValue">0</span>
      </div>
      <span class="label">Platform Tilt:</span>
      <div class="slider-row">
        <input type="range" id="tiltSlider" min="-30" max="0" step="1" value="0">
        <span class="value-label" id="tiltValue">0°</span>
      </div>
    </div>
    <div class="section">
      <button id="startBtn">Start</button>
      <button id="stopBtn">Stop</button>
      <button id="resetBtn">Restart</button>
    </div>
    <div class="section" id="telemetry">
      <div><span class="t-label">Vertical Speed:</span>
        <span class="t-value" id="telemetry-vspeed">0.00</span></div>
      <div><span class="t-label">Tilt:</span>
        <span class="t-value" id="telemetry-tilt">0°</span></div>
      <div><span class="t-label">Wind:</span>
        <span class="t-value" id="telemetry-wind">0</span></div>
      <div><span class="t-label">Status:</span>
        <span class="t-value" id="telemetry-status">Flying</span></div>
    </div>
    <div id="statusMsg" class="flying"></div>
    <div style="flex:1"></div>
    <div style="font-size: 12px; color: #9db5c7; text-align:center; margin-bottom:15px;">
      &copy; 2025 Drone Sim &mdash; Made with <span style="color:#e25555;">&#9829;</span>
    </div>
  </div>
  <div id="canvas-container"></div>
  <script type="module">
    import p5 from 'p5';
    import Matter from 'matter-js';
    const { Engine, World, Bodies, Body, Events } = Matter;

    // === Simulation Constants ===
    const DRONE_WIDTH         = 40;
    const DRONE_HEIGHT        = 10;
    const PLATFORM_WIDTH      = 200;
    const PLATFORM_HEIGHT     = 20;
    const TRUCK_CHASSIS_HEIGHT= 20;
    const TRUCK_WHEEL_DIAM    = 20;
    const ROAD_HEIGHT         = 40;
    const DASH_LENGTH         = 40;
    const DASH_GAP            = 30;
    const ROAD_SCROLL_SPEED   = 200;
    const DRONE_THRUST        = 0.0008;
    const AIR_DRAG_COEF       = 0.00002;
    const CRASH_VELOCITY_LIM  = 1.0;
    const PROPELLER_SPIN_SPEED= 0.3;
    const LANDING_LEEWAY      = 25;
    const HORIZONTAL_LEEWAY   = 100;
    const DRONE_TILT_MAX      = Math.PI/8;
    const FIRE_PARTICLES      = 30;

    // === Simulation State Variables ===
    let physicsEngine, physicsWorld;
    let droneBody, platformBody, truckCabinBody, roadBody;
    let simulationIsRunning = true;
    let droneHasLanded = false, droneHasCrashed = false;
    let windHorizontalForce = 0, platformTiltAngle = 0;
    let roadDashOffset = 0, propellerSpinAngle = 0;
    let backgroundCanvas, skyGradientTop, skyGradientBottom;
    let crashFireParticles = [];

    // --- Utility for fire effect ---
    class FireParticle {
      constructor(x, y) {
        this.x = x + (Math.random() - 0.5) * 10;
        this.y = y + (Math.random() - 0.5) * 6;
        this.vx = (Math.random() - 0.5) * 2.8;
        this.vy = -Math.random() * 2 - 1.1;
        this.life = Math.random() * 0.6 + 0.7;
        this.age = 0;
        this.size = Math.random() * 7 + 8;
        this.color = [
          [255,180,54,230],
          [255,82,32,230],
          [241,44,24,220],
          [255,255,74,190],
          [190,210,210,150]
        ][Math.floor(Math.random()*5)];
      }
      update(dt) {
        this.x += this.vx * dt * 50;
        this.y += this.vy * dt * 40;
        this.vy += 0.12 * dt * 28; // gravity
        this.age += dt;
      }
      draw(p) {
        let t = 1-Math.min(1, this.age/this.life);
        p.noStroke();
        p.fill(...this.color.map((v,i)=>i===3?v*t:v));
        p.ellipse(this.x, this.y, this.size * t, this.size * t);
      }
      isAlive() { return this.age < this.life; }
    }

    /**
     * Initializes and resets the simulation state and physics world.
     * @param {p5} p - p5 instance.
     */
    function initializeSimulation(p) {
      physicsEngine = Engine.create();
      physicsWorld  = physicsEngine.world;
      physicsWorld.gravity.x = 0;
      physicsWorld.gravity.y = 1;
      World.clear(physicsWorld, false);

      const truckBaseX = p.width * 0.35;
      const roadY      = p.height - ROAD_HEIGHT / 2;

      // --- Drone Body ---
      droneBody = Bodies.rectangle(truckBaseX, 100, DRONE_WIDTH, DRONE_HEIGHT, {
        frictionAir: 0.05,
        density: 0.001,
        label: 'drone'
      });

      // --- Platform Body (Truck bed) ---
      const truckBedY = roadY - TRUCK_WHEEL_DIAM - PLATFORM_HEIGHT / 2 - 2;
      platformBody = Bodies.rectangle(truckBaseX, truckBedY, PLATFORM_WIDTH, PLATFORM_HEIGHT, {
        isStatic: true,
        friction: 0.8,
        label: 'platform'
      });

      // --- Truck Cabin Body ---
      truckCabinBody = Bodies.rectangle(
        truckBaseX + PLATFORM_WIDTH / 2 - 15,
        truckBedY - PLATFORM_HEIGHT / 2 - 30,
        90, 60,
        { isStatic: true, friction: 0.8, label: 'cabin' }
      );

      // --- Road Body ---
      roadBody = Bodies.rectangle(
        p.width / 2, roadY,
        p.width, ROAD_HEIGHT,
        { isStatic: true, label: 'road' }
      );

      World.add(physicsWorld, [droneBody, platformBody, truckCabinBody, roadBody]);
      droneHasLanded = droneHasCrashed = false;
      simulationIsRunning = true;
      roadDashOffset = propellerSpinAngle = 0;
      crashFireParticles = [];

      // --- Collision Handler ---
      Events.on(physicsEngine, 'collisionStart', event => {
        event.pairs.forEach(pair => {
          let collidedBody = null;
          if (pair.bodyA === droneBody) collidedBody = pair.bodyB;
          else if (pair.bodyB === droneBody) collidedBody = pair.bodyA;
          if (!collidedBody) return;
          const velocity = Math.hypot(droneBody.velocity.x, droneBody.velocity.y);
          if (['road', 'platform', 'cabin'].includes(collidedBody.label)) {
            if (
              collidedBody.label === 'road' && velocity > CRASH_VELOCITY_LIM ||
              collidedBody.label !== 'road'
            ) {
              markDroneCrash();
            }
          }
        });
      });
    }

    /** Mark the drone as crashed and stop simulation, spawn fire */
    function markDroneCrash() {
      droneHasCrashed = true;
      simulationIsRunning = false;
      spawnCrashFire();
    }

    /** Mark the drone as landed and perform landing logic. */
    function markDroneLanded() { droneHasLanded = true; }

    /** Spawns fire particles at the drone's current location. */
    function spawnCrashFire() {
      crashFireParticles = [];
      let { x, y } = droneBody.position;
      for (let i=0; i<FIRE_PARTICLES; ++i)
        crashFireParticles.push(new FireParticle(x, y));
    }

    function drawSkyAndClouds(bg, p) {
      for (let y = 0; y < p.height; y++) {
        const interp = y / p.height;
        bg.stroke(p.lerpColor(skyGradientTop, skyGradientBottom, interp));
        bg.line(0, y, p.width, y);
      }
      bg.noStroke().fill(255,255,255,200);
      for (let i = 0; i < 8; i++) {
        const cx = Math.random() * p.width,
              cy = Math.random() * p.height * 0.4,
              cw = 60 + Math.random() * 80,
              ch = 20 + Math.random() * 20;
        bg.ellipse(cx, cy, cw, ch);
        bg.ellipse(cx + cw * 0.3, cy - ch * 0.2, cw * 0.6, ch * 0.6);
        bg.ellipse(cx - cw * 0.3, cy - ch * 0.1, cw * 0.5, ch * 0.5);
      }
    }

    /**
     * Draws the scrolling road with dashed lines.
     * @param {p5} p - p5 instance.
     */
    function drawRoad(p) {
      const roadCenterY = p.height - ROAD_HEIGHT / 2;
      p.fill(50).noStroke();
      p.rect(p.width / 2, roadCenterY, p.width, ROAD_HEIGHT);
      p.fill(255);
      let dashStartX = -roadDashOffset;
      while (dashStartX < p.width) {
        p.rect(dashStartX + DASH_LENGTH / 2, roadCenterY, DASH_LENGTH, 4);
        dashStartX += DASH_LENGTH + DASH_GAP;
      }
    }

    /**
     * Renders the truck, including heels chassis, tilting platform, and cabin)
     * @param {p5} p - p5 instance.
     */
    function drawTruck(p) {
      const truckCenterX   = platformBody.position.x;
      const roadCenterY    = p.height - ROAD_HEIGHT / 2;
      const wheelCenterY   = roadCenterY - TRUCK_WHEEL_DIAM / 2;
      const chassisCenterY = wheelCenterY - TRUCK_WHEEL_DIAM / 2 - TRUCK_CHASSIS_HEIGHT / 2;
      const platformPivotY = chassisCenterY - TRUCK_CHASSIS_HEIGHT / 2;
      const platformPivotX = truckCenterX - PLATFORM_WIDTH * 0.25;

      // Draw wheels
      const wheelOffsetX = PLATFORM_WIDTH * 0.3;
      [-wheelOffsetX, wheelOffsetX].forEach(offsetX => {
        p.fill(0).ellipse(truckCenterX + offsetX, wheelCenterY, TRUCK_WHEEL_DIAM, TRUCK_WHEEL_DIAM);
        p.fill(150).ellipse(truckCenterX + offsetX, wheelCenterY, TRUCK_WHEEL_DIAM * 0.6, TRUCK_WHEEL_DIAM * 0.6);
      });

      // Draw truck chassis
      p.push();
      p.translate(truckCenterX, chassisCenterY);
      p.fill(80).noStroke();
      p.rect(0, 0, PLATFORM_WIDTH, TRUCK_CHASSIS_HEIGHT);
      p.pop();

      // Draw a tilting platform (truck bed)
      p.push();
      p.translate(platformPivotX, platformPivotY);
      p.rotate(platformTiltAngle);
      p.fill(100).noStroke();
      p.rect(0, -PLATFORM_HEIGHT / 2, PLATFORM_WIDTH, PLATFORM_HEIGHT);
      p.stroke(150).strokeWeight(2);
      for (let i = 1; i < 6; i++) {
        const lx = -PLATFORM_WIDTH / 2 + (PLATFORM_WIDTH / 6) * i;
        p.line(lx, -PLATFORM_HEIGHT, lx, 0);
      }
      p.pop();

      // Draw a cabin
      p.fill(255,204,0);
      p.rect(truckCabinBody.position.x, truckCabinBody.position.y, 90, 60);

      // Draw platform pivot point
      p.fill(80).ellipse(platformPivotX, platformPivotY, 12, 12);
    }

    /**
     * Draws the quadcopter drone with spinning propellers.
     * @param {p5} p - p5 instance.
     */
    function drawDrone(p) {
      const {x, y} = droneBody.position, angle = droneBody.angle;

      // --- Calculate roll/tilt effect based on velocity ---
      let vx = droneBody.velocity.x;
      let roll = Math.max(-DRONE_TILT_MAX, Math.min(DRONE_TILT_MAX, vx * 1.2)); // scale factor, limit max
      let effectiveAngle = angle + roll;

      const halfWidth = DRONE_WIDTH / 2;
      p.push();
      p.translate(x, y);
      p.rotate(effectiveAngle);
      p.fill(255,204,0).noStroke();
      p.rect(0, 0, DRONE_WIDTH, DRONE_HEIGHT, 7);

      // Draw shadow (ellipse)
      if (!droneHasCrashed && !droneHasLanded) {
        p.push();
        p.noStroke();
        p.fill(60,80,80,60);
        p.ellipse(0, 15, DRONE_WIDTH*1.4, DRONE_HEIGHT*1.1);
        p.pop();
      }

      // Draw propellers
      [-halfWidth, halfWidth].forEach(propellerX => {
        p.fill(0).ellipse(propellerX, 0, 10);
        p.push();
        p.translate(propellerX, 0);
        p.stroke(0).strokeWeight(2);
        if (!droneHasLanded && !droneHasCrashed) p.rotate(propellerSpinAngle);
        p.line(-12,0,12,0);
        p.rotate(Math.PI/2);
        p.line(-12,0,12,0);
        p.pop();
        p.noStroke();
      });
      p.pop();
    }

    // Draw crash fire and sparks
    function drawCrashFire(p) {
      for (let particle of crashFireParticles) {
        particle.draw(p);
      }
    }

    // --- UI/Telemetry update ---
    function updateSidebarTelemetry(vspeed, tilt, wind, status) {
      document.getElementById('telemetry-vspeed').textContent = vspeed.toFixed(2);
      document.getElementById('telemetry-tilt').textContent = tilt;
      document.getElementById('telemetry-wind').textContent = wind;
      document.getElementById('telemetry-status').textContent = status;
      let msg = document.getElementById('statusMsg');
      msg.className = "";
      if(status === "Crashed") msg.classList.add("crash"), msg.textContent="Crash! Drone destroyed.";
      else if(status === "Landed") msg.classList.add("success"), msg.textContent="Success! Drone landed.";
      else msg.classList.add("flying"), msg.textContent="Flying...";
    }

    // --- Main p5 sketch ---
    const simulationSketch = p => {
      p.setup = () => {
        let w = window.innerWidth - document.getElementById('sidebar').offsetWidth;
        let h = window.innerHeight;
        let c = p.createCanvas(w, h);
        c.parent("canvas-container");
        p.rectMode(p.CENTER);
        p.angleMode(p.RADIANS);
        skyGradientTop     = p.color(135,206,235);
        skyGradientBottom  = p.color(250,222,156);
        backgroundCanvas   = p.createGraphics(p.width,p.height);
        drawSkyAndClouds(backgroundCanvas, p);
        initializeSimulation(p);
      };

      p.windowResized = () => {
        let w = window.innerWidth - document.getElementById('sidebar').offsetWidth;
        let h = window.innerHeight;
        p.resizeCanvas(w, h);
        backgroundCanvas = p.createGraphics(p.width,p.height);
        drawSkyAndClouds(backgroundCanvas, p);
        initializeSimulation(p);
      };

      p.draw = () => {
        const deltaTimeSec = p.deltaTime / 1000;

        if (simulationIsRunning) {
          Engine.update(physicsEngine, p.deltaTime);
          roadDashOffset = (roadDashOffset + ROAD_SCROLL_SPEED * deltaTimeSec) % (DASH_LENGTH + DASH_GAP);
          if (!droneHasLanded && !droneHasCrashed) propellerSpinAngle += PROPELLER_SPIN_SPEED;

          // --- Apply environmental and control forces ---
          Body.applyForce(droneBody, droneBody.position, { x: windHorizontalForce, y: 0 });
          const {x: vx, y: vy} = droneBody.velocity;
          Body.applyForce(droneBody, droneBody.position, {
            x: -AIR_DRAG_COEF * vx * Math.abs(vx),
            y: -AIR_DRAG_COEF * vy * Math.abs(vy)
          });

          // --- User controls (Arrow keys) ---
          if (!droneHasLanded && !droneHasCrashed) {
            if (p.keyIsDown(p.LEFT_ARROW))  Body.applyForce(droneBody, droneBody.position, { x: -DRONE_THRUST, y: 0 });
            if (p.keyIsDown(p.RIGHT_ARROW)) Body.applyForce(droneBody, droneBody.position, { x:  DRONE_THRUST, y: 0 });
            if (p.keyIsDown(p.UP_ARROW))    Body.applyForce(droneBody, droneBody.position, { x: 0, y: -DRONE_THRUST });
            if (p.keyIsDown(p.DOWN_ARROW))  Body.applyForce(droneBody, droneBody.position, { x: 0, y:  DRONE_THRUST });
          }
        }

        // --- Crash on hitting top of the screen ---
        if (!droneHasLanded && !droneHasCrashed) {
          if (droneBody.position.y < 0) {
            markDroneCrash();
          }
        }

        // --- Landing Detection ---
        if (!droneHasLanded && !droneHasCrashed) {
          // Calculate drone's bottom center in world coordinates
          const droneBottomCenter = {
            x: droneBody.position.x + Math.sin(droneBody.angle) * (DRONE_HEIGHT / 2),
            y: droneBody.position.y + Math.cos(droneBody.angle) * (DRONE_HEIGHT / 2)
          };
          // Platform's top center in world coordinates
          const ca = Math.cos(platformTiltAngle), sa = Math.sin(platformTiltAngle);
          const platformTopCenter = {
            x: platformBody.position.x - sa * (PLATFORM_HEIGHT / 2),
            y: platformBody.position.y - ca * (PLATFORM_HEIGHT / 2)
          };
          // Platform surface normal
          const platformNormalX = -sa, platformNormalY = -ca;
          const dx = droneBottomCenter.x - platformTopCenter.x;
          const dy = droneBottomCenter.y - platformTopCenter.y;
          // Distance from drone bottom to platform top along normal
          const normalDist = dx * platformNormalX + dy * platformNormalY;
          // Tangential (horizontal) offset along the platform
          const tangentDist = dx * ca + dy * sa;
          const landingLimit = (PLATFORM_WIDTH / 2) - (DRONE_WIDTH / 2) + HORIZONTAL_LEEWAY;
          // Landing check
          if (
            Math.abs(normalDist) < LANDING_LEEWAY &&
            Math.abs(tangentDist) < landingLimit &&
            Math.abs(droneBody.velocity.y) < CRASH_VELOCITY_LIM &&
            Math.abs(droneBody.velocity.x) < CRASH_VELOCITY_LIM
          ) {
            markDroneLanded();
          }
        }

        // --- Rendering ---
        p.clear();
        p.image(backgroundCanvas, 0, 0);

        drawRoad(p);
        drawTruck(p);
        drawDrone(p);

        // --- Crash, fire, and sparks
        if (droneHasCrashed) {
          crashFireParticles.forEach(f => f.update(deltaTimeSec));
          crashFireParticles = crashFireParticles.filter(f => f.isAlive());
          drawCrashFire(p);
        }

        // --- Telemetry / Status ---
        const verticalVelocity = droneBody.velocity.y;
        const platformAngleDeg = (platformTiltAngle * 180 / Math.PI).toFixed(1) + '°';
        const windDisplay      = (windHorizontalForce / 0.00002).toFixed(0);
        const status = droneHasCrashed ? 'Crashed' : droneHasLanded ? 'Landed' : 'Flying';

        updateSidebarTelemetry(verticalVelocity, platformAngleDeg, windDisplay, status);

        // --- Snap drone to rest on platform after landing ---
        if (droneHasLanded) {
          const ca = Math.cos(platformTiltAngle), sa = Math.sin(platformTiltAngle);
          const platformTopY = platformBody.position.y - ca * (PLATFORM_HEIGHT / 2);
          Body.setPosition(droneBody, {
            x: droneBody.position.x,
            y: platformTopY - 20
          });
          Body.setAngle(droneBody, platformTiltAngle);
          Body.setVelocity(droneBody, { x: 0, y: 0 });
          Body.setAngularVelocity(droneBody, 0);
        }
      };
    };

    // --- Create p5 instance ---
    window.p5Instance = new p5(simulationSketch);

    // === UI Event Listeners ===
    document.getElementById('startBtn').onclick = () => simulationIsRunning = true;
    document.getElementById('stopBtn').onclick  = () => simulationIsRunning = false;
    document.getElementById('resetBtn').onclick = () => {
      initializeSimulation(window.p5Instance);
      windHorizontalForce = platformTiltAngle = roadDashOffset = propellerSpinAngle = 0;
      document.getElementById('windSlider').value = 0;
      document.getElementById('tiltSlider').value = 0;
      document.getElementById('windValue').textContent = '0';
      document.getElementById('tiltValue').textContent = '0°';
    };
    document.getElementById('windSlider').oninput = e => {
      windHorizontalForce = Number(e.target.value) * 0.00002;
      document.getElementById('windValue').textContent = e.target.value;
    };
    document.getElementById('tiltSlider').oninput = e => {
      const degrees = Number(e.target.value);
      platformTiltAngle = degrees * Math.PI / 180;
      document.getElementById('tiltValue').textContent = `${degrees}°`;
    };

    // --- Initial Telemetry UI Update
    document.getElementById('statusMsg').textContent = "Flying...";
  </script>
</body>
</html>
