<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive 2D Waterfall Simulation</title>
  <script type="importmap">
  {
    "imports": {
      "p5":        "https://cdn.skypack.dev/p5@1.4.0",
      "matter-js": "https://cdn.skypack.dev/matter-js@0.18.0"
    }
  }
  </script>
</head>
<body>
  <script type="module">
    import P5 from 'p5';
    import Matter from 'matter-js';

    /**
     * Main p5 sketch function.
     * @param {P5} p5Canvas - The p5 instance.
     */
    const sketch = (p5Canvas) => {
      // Physics engine and world
      let physicsEngine;
      let physicsWorld;

      // Collections for static rocks and dynamic water particles
      const rockBodies = [];
      const fallingDrops = [];
      const splashDrops = [];
      const pooledDrops = [];

      // UI controls and state
      let waterFlowRate = 10;
      let flowRateSlider;
      let draggedRock = null;

      /**
       * Initialize the Matter.js physics engine and world.
       */
      function initializePhysics() {
        physicsEngine = Matter.Engine.create();
        physicsWorld = physicsEngine.world;
      }

      /**
       * Generate an irregular rock mesh at fixed positions.
       */
      function loadIrregularRocks() {
        const positions = [
          { x: 200, y: 450 },
          { x: 400, y: 400 },
          { x: 600, y: 500 },
          { x: 300, y: 350 },
          { x: 500, y: 300 }
        ];

        positions.forEach(({ x: centerX, y: centerY }) => {
          const vertexCount = p5Canvas.floor(p5Canvas.random(6, 12));
          const minRadius = 30;
          const maxRadius = 60;
          const vertices = [];

          // Create random radii for each angle
          for (let angleIndex = 0; angleIndex < vertexCount; angleIndex++) {
            const angle = (Math.PI * 2 / vertexCount) * angleIndex;
            const radius = p5Canvas.random(minRadius, maxRadius);
            const vx = radius * Math.cos(angle);
            const vy = radius * Math.sin(angle);
            vertices.push({ x: vx, y: vy });
          }

          // Build a Matter body from the vertices
          const rock = Matter.Bodies.fromVertices(
            centerX,
            centerY,
            [vertices],
            { isStatic: true, render: { fillStyle: '#555555' } }
          );
          Matter.World.add(physicsWorld, rock);
          rockBodies.push(rock);
        });
      }

      /**
       * Emit new water drops at the top center of the canvas.
       */
      function spawnWaterDrops() {
        for (let dropIndex = 0; dropIndex < waterFlowRate; dropIndex++) {
          const radius = p5Canvas.random(2, 4);
          const startX = p5Canvas.width / 2 + p5Canvas.random(-10, 10);
          fallingDrops.push(new WaterDrop(startX, 0, radius));
        }
      }

      /**
       * Represents a single water particle.
       */
      class WaterDrop {
        constructor(x, y, radius) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.vx = p5Canvas.random(-1, 1);
          this.vy = p5Canvas.random(0, 2);
        }

        update() {
          this.vy += 0.1; // gravity
          this.x += this.vx;
          this.y += this.vy;

          // Eddy formation: deflect when near a rock
          rockBodies.forEach(rock => {
            const dx = this.x - rock.position.x;
            const dy = this.y - rock.position.y;
            const dist = Math.hypot(dx, dy);
            const eddyRadius = 80;
            if (dist > this.radius + rock.circleRadius && dist < eddyRadius) {
              const perpX = -dy / dist;
              const perpY = dx / dist;
              const strength = 0.05;
              this.vx += perpX * strength;
              this.vy += perpY * strength;
            }
          });
        }

        draw() {
          p5Canvas.noStroke();
          p5Canvas.fill(0, 100, 255, 180);
          p5Canvas.ellipse(this.x, this.y, this.radius * 2);
        }

        isOffScreen() {
          return this.y > p5Canvas.height || this.x < 0 || this.x > p5Canvas.width;
        }

        hitsRock(rock) {
          return Matter.Query.point([rock], { x: this.x, y: this.y }).length > 0;
        }
      }

      /**
       * Update all particles and handle pooling at the bottom.
       */
      function updateParticles() {
        for (let i = fallingDrops.length - 1; i >= 0; i--) {
          const drop = fallingDrops[i];
          drop.update();

          // Pooling: collect drops that slow near the bottom
          if (drop.y > p5Canvas.height - 10 && Math.abs(drop.vy) < 0.5) {
            pooledDrops.push(drop);
            fallingDrops.splice(i, 1);
          } else if (drop.isOffScreen()) {
            fallingDrops.splice(i, 1);
          }
        }

        // Update and remove splash drops
        for (let j = splashDrops.length - 1; j >= 0; j--) {
          const splash = splashDrops[j];
          splash.update();
          if (splash.isOffScreen()) {
            splashDrops.splice(j, 1);
          }
        }
      }

      /**
       * Detect collisions, spawn splashes.
       */
      function detectCollisions() {
        const splashCount = 7;

        for (let i = fallingDrops.length - 1; i >= 0; i--) {
          const drop = fallingDrops[i];
          for (const rock of rockBodies) {
            if (drop.hitsRock(rock)) {
              for (let k = 0; k < splashCount; k++) {
                const splash = new WaterDrop(drop.x, drop.y, p5Canvas.random(1, 3));
                splash.vx = p5Canvas.random(-3, 3);
                splash.vy = p5Canvas.random(-3, 0);
                splashDrops.push(splash);
              }
              fallingDrops.splice(i, 1);
              break;
            }
          }
        }
      }

      /**
       * Render pooled water as a translucent layer at the bottom.
       */
      function renderPool() {
        p5Canvas.noStroke();
        p5Canvas.fill(0, 120, 255, 200);
        pooledDrops.forEach(drop => {
          p5Canvas.ellipse(drop.x, p5Canvas.height - 5, drop.radius * 2);
        });
      }

      /**
       * Draw static rocks.
       */
      function renderRocks() {
        p5Canvas.fill(80);
        rockBodies.forEach(rock => {
          p5Canvas.beginShape();
          rock.vertices.forEach(vertex => p5Canvas.vertex(vertex.x, vertex.y));
          p5Canvas.endShape(p5Canvas.CLOSE);
        });
      }

      /**
       * Set up slider with a label and drag-and-drop for rocks.
       */
      function setupControls() {
        const label = p5Canvas.createDiv('Flow rate:');
        label.position(10, 10);
        flowRateSlider = p5Canvas.createSlider(1, 50, waterFlowRate);
        flowRateSlider.position(100, 10);
        flowRateSlider.input(() => waterFlowRate = flowRateSlider.value());

        p5Canvas.mousePressed = () => {
          rockBodies.forEach(rock => {
            const d = p5Canvas.dist(p5Canvas.mouseX, p5Canvas.mouseY, rock.position.x, rock.position.y);
            if (d < 60) draggedRock = rock;
          });
        };
        p5Canvas.mouseDragged = () => {
          if (draggedRock) {
            Matter.Body.setPosition(draggedRock, { x: p5Canvas.mouseX, y: p5Canvas.mouseY });
          }
        };
        p5Canvas.mouseReleased = () => { draggedRock = null; };
      }

      /**
       * Draw a sky-to-ground gradient background.
       */
      function drawGradientBackground() {
        // Draw a sky-to-ground gradient manually using Canvas API
        const ctx = p5Canvas.drawingContext;
        const gradient = ctx.createLinearGradient(0, 0, p5Canvas.width, p5Canvas.height);
        gradient.addColorStop(0, '#87CEEB');  // sky blue
        gradient.addColorStop(1, '#FFFFFF');  // white ground
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, p5Canvas.width, p5Canvas.height);
      }

      /**
       * Main animation loop: update physics, particles, and draw.
       */
      function animate() {
        drawGradientBackground();
        spawnWaterDrops();
        updateParticles();
        detectCollisions();
        renderRocks();
        fallingDrops.forEach(d => d.draw());
        splashDrops.forEach(d => d.draw());
        renderPool();

        Matter.Engine.update(physicsEngine);
        requestAnimationFrame(animate);
      }

      // p5.js setup
      p5Canvas.setup = () => {
        p5Canvas.createCanvas(800, 600);
        initializePhysics();
        loadIrregularRocks();
        setupControls();
        animate();
      };
    };

    new P5(sketch);
  </script>
</body>
</html>
