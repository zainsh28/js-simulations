<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive 2D Waterfall Simulation</title>
  <script type="importmap">
  {
    "imports": {
      "p5":        "https://cdn.skypack.dev/p5@1.4.0",
      "matter-js": "https://cdn.skypack.dev/matter-js@0.18.0"
    }
  }
  </script>
</head>
<body>
  <script type="module">
    import P5 from 'p5';
    import Matter from 'matter-js';

    /**
     * Main p5 sketch function.
     * @param {P5} p5Canvas - The p5 instance.
     */
    const sketch = (p5Canvas) => {
      // Physics engine and world
      let physicsEngine;
      let physicsWorld;

      // Collections for static rocks and dynamic water particles/pools
      const rockBodies = [];
      const fallingDrops = [];
      const splashDrops = [];
      const pooledDrops = [];

      // UI controls and state
      let waterFlowRate = 10;
      let flowRateSlider;
      let eddyStrength = 0.02;
      let eddySlider;

      // Perlin noise seed for eddies
      let noiseSeedVal;
      let draggedRock = null;

      /**
       * Initialize the Matter.js physics engine and world.
       */
      function initializePhysics() {
        physicsEngine = Matter.Engine.create();
        physicsWorld = physicsEngine.world;
        noiseSeedVal = p5Canvas.random(1000);
      }

      /**
       * Generate irregular rock meshes in three tiers (tight cluster).
       */
      function loadIrregularRocks() {
        const cx = p5Canvas.width / 2;
        const tiers = [
          { x: cx,      y: 320 },
          { x: cx - 40, y: 380 },
          { x: cx + 40, y: 380 },
          { x: cx - 80, y: 440 },
          { x: cx,      y: 480 },
          { x: cx + 80, y: 440 }
        ];

        tiers.forEach(({ x: centerX, y: centerY }) => {
          const vertexCount = p5Canvas.floor(p5Canvas.random(6, 12));
          const minR = 30, maxR = 60;
          const verts = [];
          for (let i = 0; i < vertexCount; i++) {
            const angle = (Math.PI * 2 / vertexCount) * i;
            const r = p5Canvas.random(minR, maxR);
            verts.push({ x: r * Math.cos(angle), y: r * Math.sin(angle) });
          }
          const rock = Matter.Bodies.fromVertices(centerX, centerY, [verts], { isStatic: true });
          Matter.World.add(physicsWorld, rock);
          rockBodies.push(rock);
        });
      }

      /**
       * Emit new water drops at the top center of the canvas.
       */
      function spawnWaterDrops() {
        for (let i = 0; i < waterFlowRate; i++) {
          const r = p5Canvas.random(2, 4);
          const startX = p5Canvas.width / 2 + p5Canvas.random(-10, 10);
          fallingDrops.push(new WaterDrop(startX, 0, r));
        }
      }

      /**
       * Represents a single water particle with Perlin‐noise eddies and added swirl.
       */
      class WaterDrop {
        constructor(x, y, radius) {
          this.x = x;
          this.y = y;
          this.radius = radius;
          this.vx = p5Canvas.random(-1, 1);
          this.vy = p5Canvas.random(0, 2);
        }

        update() {
          this.vy += 0.1; // gravity
          this.x += this.vx;
          this.y += this.vy;

          // Eddy + swirl around each rock
          const eddyR = 80;
          const noiseScale = 0.005;
          rockBodies.forEach(rock => {
            const dx = this.x - rock.position.x;
            const dy = this.y - rock.position.y;
            const d = Math.hypot(dx, dy);
            if (d < eddyR) {
              // radial angle from rock to drop
              const baseAngle = Math.atan2(dy, dx);
              // choose spin direction based on quadrant
              const spinDir = (dx * dy > 0) ? 1 : -1;

              // 1) Perlin‐noise jitter
              const noiseAng = p5Canvas.noise(
                (this.x + noiseSeedVal) * noiseScale,
                (this.y + noiseSeedVal) * noiseScale
              ) * Math.PI * 2;
              const noiseStr = p5Canvas.map(d, 0, eddyR, 0.2, 0);

              // 2) Tangential swirl component
              const tanAngle = baseAngle + (Math.PI / 2) * spinDir;
              const swirlStr = p5Canvas.map(d, 0, eddyR, eddyStrength, 0);

              // apply both effects
              this.vx += Math.cos(noiseAng) * noiseStr
                       + Math.cos(tanAngle) * swirlStr;
              this.vy += Math.sin(noiseAng) * noiseStr
                       + Math.sin(tanAngle) * swirlStr;
            }
          });
        }

        draw() {
          p5Canvas.noStroke();
          p5Canvas.fill(0, 100, 255, 180);
          p5Canvas.ellipse(this.x, this.y, this.radius * 2);
        }

        isOffScreen() {
          return this.y > p5Canvas.height || this.x < 0 || this.x > p5Canvas.width;
        }

        hitsRock(rock) {
          return Matter.Query.point([rock], { x: this.x, y: this.y }).length > 0;
        }
      }

      /**
       * Update all particles and handle pooling at rock surfaces & bottom.
       */
      function updateParticles() {
        // falling drops
        for (let i = fallingDrops.length - 1; i >= 0; i--) {
          const d = fallingDrops[i];
          d.update();

          // bottom pooling
          if (d.y > p5Canvas.height - 10 && Math.abs(d.vy) < 0.5) {
            pooledDrops.push({ x: d.x, y: p5Canvas.height - 5, radius: d.radius });
            fallingDrops.splice(i, 1);
          }
          // off-screen
          else if (d.isOffScreen()) {
            fallingDrops.splice(i, 1);
          }
        }

        // splash drops
        for (let j = splashDrops.length - 1; j >= 0; j--) {
          const s = splashDrops[j];
          s.update();
          if (s.isOffScreen()) {
            splashDrops.splice(j, 1);
          }
        }
      }

      /**
       * Detect collisions, spawn splashes or pool drops on rock surfaces.
       */
      function detectCollisions() {
        const splashCount = 7;
        const poolThreshold = 1.0;

        for (let i = fallingDrops.length - 1; i >= 0; i--) {
          const d = fallingDrops[i];
          for (const rock of rockBodies) {
            if (d.hitsRock(rock)) {
              if (Math.abs(d.vy) < poolThreshold) {
                // pool on the rock surface
                pooledDrops.push({
                  x: d.x,
                  y: rock.position.y - d.radius - 2,
                  radius: d.radius
                });
              } else {
                // generate splashes
                for (let k = 0; k < splashCount; k++) {
                  const s = new WaterDrop(d.x, d.y, p5Canvas.random(1, 3));
                  s.vx = p5Canvas.random(-3, 3);
                  s.vy = p5Canvas.random(-3, 0);
                  splashDrops.push(s);
                }
              }
              fallingDrops.splice(i, 1);
              break;
            }
          }
        }
      }

      /**
       * Render pooled water as translucent ellipses.
       */
      function renderPool() {
        p5Canvas.noStroke();
        p5Canvas.fill(0, 120, 255, 150);
        pooledDrops.forEach(p => {
          p5Canvas.ellipse(p.x, p.y, p.radius * 4, p.radius * 2);
        });
      }

      /**
       * Draw static rocks.
       */
      function renderRocks() {
        p5Canvas.fill(80);
        rockBodies.forEach(rock => {
          p5Canvas.beginShape();
          rock.vertices.forEach(v => p5Canvas.vertex(v.x, v.y));
          p5Canvas.endShape(p5Canvas.CLOSE);
        });
      }

      /**
       * Set up flow‐rate & eddy strength sliders with labels, and rock drag/drop.
       */
      function setupControls() {
        // Flow Rate label & slider
        const flowLabel = p5Canvas.createSpan('Flow Rate');
        flowLabel.position(10, 10);
        flowRateSlider = p5Canvas.createSlider(1, 50, waterFlowRate);
        flowRateSlider.position(100, 10);
        flowRateSlider.input(() => waterFlowRate = flowRateSlider.value());

        // Eddy Strength label & slider
        const eddyLabel = p5Canvas.createSpan('Eddy Strength');
        eddyLabel.position(10, 40);
        eddySlider = p5Canvas.createSlider(0, 100, 20);
        eddySlider.position(100, 40);
        eddySlider.input(() => eddyStrength = eddySlider.value() / 1000);

        p5Canvas.mousePressed = () => {
          rockBodies.forEach(r => {
            const d = p5Canvas.dist(p5Canvas.mouseX, p5Canvas.mouseY, r.position.x, r.position.y);
            if (d < 60) draggedRock = r;
          });
        };
        p5Canvas.mouseDragged = () => {
          if (draggedRock) {
            Matter.Body.setPosition(draggedRock, {
              x: p5Canvas.mouseX,
              y: p5Canvas.mouseY
            });
          }
        };
        p5Canvas.mouseReleased = () => { draggedRock = null; };
      }

      /**
       * Draw sky‐to‐ground gradient & land‐like bottom.
       */
      function drawGradientBackground() {
        const ctx = p5Canvas.drawingContext;
        const skyTop = p5Canvas.color(135, 206, 235);
        const skyBot = p5Canvas.color(255, 255, 255);
        for (let y = 0; y <= p5Canvas.height; y++) {
          const t = p5Canvas.map(y, 0, p5Canvas.height, 0, 1);
          p5Canvas.stroke(p5Canvas.lerpColor(skyTop, skyBot, t));
          p5Canvas.line(0, y, p5Canvas.width, y);
        }
        const groundY = p5Canvas.height * 0.6;
        const grad = ctx.createLinearGradient(0, groundY, 0, p5Canvas.height);
        grad.addColorStop(0, '#A67B5B');
        grad.addColorStop(1, '#6B4423');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        for (let x = 0; x <= p5Canvas.width; x += 10) {
          const yOff = p5Canvas.noise(x * 0.01, p5Canvas.frameCount * 0.002) * 20;
          ctx.lineTo(x, groundY + yOff);
        }
        ctx.lineTo(p5Canvas.width, p5Canvas.height);
        ctx.lineTo(0, p5Canvas.height);
        ctx.closePath();
        ctx.fill();
        p5Canvas.noStroke();
        for (let i = 0; i < 100; i++) {
          p5Canvas.fill(80, 50, 20, 50);
          p5Canvas.ellipse(
            p5Canvas.random(0, p5Canvas.width),
            p5Canvas.random(groundY, p5Canvas.height),
            p5Canvas.random(2, 5),
            p5Canvas.random(2, 5)
          );
        }
      }

      /**
       * Main animation loop.
       */
      function animate() {
        drawGradientBackground();
        spawnWaterDrops();
        updateParticles();
        detectCollisions();
        renderRocks();
        fallingDrops.forEach(d => d.draw());
        splashDrops.forEach(d => d.draw());
        renderPool();
        Matter.Engine.update(physicsEngine);
        requestAnimationFrame(animate);
      }

      // p5.js setup
      p5Canvas.setup = () => {
        p5Canvas.createCanvas(p5Canvas.windowWidth, 700);
        initializePhysics();
        loadIrregularRocks();
        setupControls();
        animate();
      };

      p5Canvas.windowResized = () => {
        p5Canvas.resizeCanvas(p5Canvas.windowWidth, p5Canvas.windowHeight);
      };
    };

    new P5(sketch);
  </script>
</body>
</html>
